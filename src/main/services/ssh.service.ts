/**
 * SSH Service
 * 
 * Manages SSH keys and SSH config.
 * Never reads private key contents - only stores paths.
 */

import * as fs from 'fs/promises';
import * as path from 'path';
import { spawn } from 'child_process';
import {
    createLogger,
    getSSHDir,
    getSSHConfigPath,
    pathExists,
    safeReadFile,
    ensureDir,
    expandTilde
} from '../utils';
import { backupService } from './backup.service';
import { auditService } from './audit.service';
import type { SSHKeyInfo, SSHConfigEntry } from '../../shared/types';

const logger = createLogger('SSHService');

/**
 * Execute a command and return output
 */
function execAsync(command: string, args: string[]): Promise<string> {
    return new Promise((resolve, reject) => {
        const child = spawn(command, args, {
            shell: false,
            stdio: ['pipe', 'pipe', 'pipe'],
        });

        let stdout = '';
        let stderr = '';

        child.stdout?.on('data', (data) => {
            stdout += data.toString();
        });

        child.stderr?.on('data', (data) => {
            stderr += data.toString();
        });

        child.on('close', (code) => {
            if (code === 0) {
                resolve(stdout.trim());
            } else {
                reject(new Error(stderr || `Command exited with code ${code}`));
            }
        });

        child.on('error', reject);
    });
}

/**
 * Parse SSH config file
 */
function parseSSHConfig(content: string): SSHConfigEntry[] {
    const entries: SSHConfigEntry[] = [];
    let currentEntry: SSHConfigEntry | null = null;

    for (const line of content.split('\n')) {
        const trimmed = line.trim();

        // Skip comments and empty lines
        if (!trimmed || trimmed.startsWith('#')) {
            continue;
        }

        // Match key-value pair
        const match = trimmed.match(/^(\S+)\s+(.+)$/);
        if (!match) continue;

        const [, key, value] = match;
        const lowerKey = key.toLowerCase();

        // Start new host entry
        if (lowerKey === 'host') {
            if (currentEntry) {
                entries.push(currentEntry);
            }
            currentEntry = { host: value };
            continue;
        }

        // Add property to current entry
        if (currentEntry) {
            switch (lowerKey) {
                case 'hostname':
                    currentEntry.hostName = value;
                    break;
                case 'user':
                    currentEntry.user = value;
                    break;
                case 'identityfile':
                    currentEntry.identityFile = expandTilde(value);
                    break;
                case 'identitiesonly':
                    currentEntry.identitiesOnly = value.toLowerCase() === 'yes';
                    break;
                case 'port':
                    currentEntry.port = parseInt(value, 10);
                    break;
                default:
                    currentEntry[lowerKey] = value;
            }
        }
    }

    // Don't forget the last entry
    if (currentEntry) {
        entries.push(currentEntry);
    }

    return entries;
}

/**
 * Generate SSH config content from entries
 */
function generateSSHConfig(entries: SSHConfigEntry[]): string {
    const lines: string[] = [
        '# SSH Config - Managed by GitSwitch',
        '# Do not edit this file manually',
        '',
    ];

    for (const entry of entries) {
        lines.push(`Host ${entry.host}`);

        if (entry.hostName) lines.push(`    HostName ${entry.hostName}`);
        if (entry.user) lines.push(`    User ${entry.user}`);
        if (entry.identityFile) lines.push(`    IdentityFile ${entry.identityFile}`);
        if (entry.identitiesOnly !== undefined) {
            lines.push(`    IdentitiesOnly ${entry.identitiesOnly ? 'yes' : 'no'}`);
        }
        if (entry.port) lines.push(`    Port ${entry.port}`);

        // Add any other properties
        for (const [key, value] of Object.entries(entry)) {
            if (!['host', 'hostName', 'user', 'identityFile', 'identitiesOnly', 'port'].includes(key)) {
                lines.push(`    ${key.charAt(0).toUpperCase() + key.slice(1)} ${value}`);
            }
        }

        lines.push('');
    }

    return lines.join('\n');
}

/**
 * SSH Service API
 */
export const sshService = {
    /**
     * List all SSH keys in ~/.ssh
     */
    async listKeys(): Promise<SSHKeyInfo[]> {
        const sshDir = getSSHDir();

        if (!(await pathExists(sshDir))) {
            return [];
        }

        const keys: SSHKeyInfo[] = [];

        try {
            const files = await fs.readdir(sshDir);
            const pubFiles = files.filter(f => f.endsWith('.pub'));

            for (const pubFile of pubFiles) {
                const privatePath = path.join(sshDir, pubFile.replace('.pub', ''));
                const publicPath = path.join(sshDir, pubFile);

                // Only include if private key exists
                if (!(await pathExists(privatePath))) {
                    continue;
                }

                // Get public key info
                try {
                    const pubContent = await safeReadFile(publicPath);
                    if (!pubContent) continue;

                    // Parse public key format: type base64 comment
                    const parts = pubContent.trim().split(/\s+/);
                    const keyType = parts[0]?.replace('ssh-', '');
                    const comment = parts[2] || undefined;

                    // Get fingerprint
                    let fingerprint: string | undefined;
                    try {
                        const output = await execAsync('ssh-keygen', ['-lf', publicPath]);
                        const fpMatch = output.match(/^\d+\s+([^\s]+)/);
                        fingerprint = fpMatch?.[1];
                    } catch {
                        // Fingerprint is optional
                    }

                    keys.push({
                        privatePath,
                        publicPath,
                        keyType,
                        comment,
                        fingerprint,
                    });
                } catch (error) {
                    logger.debug('Failed to parse key', { pubFile, error });
                }
            }
        } catch (error) {
            logger.error('Failed to list SSH keys', error);
        }

        return keys;
    },

    /**
     * Generate a new SSH key
     */
    async generateKey(options: {
        email: string;
        label: string;
        type?: 'ed25519' | 'rsa';
        passphrase?: string;
    }): Promise<SSHKeyInfo> {
        const { email, label, type = 'ed25519', passphrase = '' } = options;

        const sshDir = getSSHDir();
        await ensureDir(sshDir);

        // Generate safe filename
        const safeName = `id_gitswitch_${label.toLowerCase().replace(/[^a-z0-9]/g, '_')}`;
        const privatePath = path.join(sshDir, safeName);
        const publicPath = `${privatePath}.pub`;

        // Check if key already exists
        if (await pathExists(privatePath)) {
            throw new Error(`SSH key already exists at ${privatePath}`);
        }

        // Generate key
        const args = [
            '-t', type,
            '-C', email,
            '-f', privatePath,
            '-N', passphrase,
        ];

        if (type === 'rsa') {
            args.push('-b', '4096');
        }

        try {
            await execAsync('ssh-keygen', args);
        } catch (error) {
            logger.error('Failed to generate SSH key', error);
            throw new Error(`Failed to generate SSH key: ${(error as Error).message}`);
        }

        // Get key info
        const pubContent = await safeReadFile(publicPath);
        const parts = pubContent?.trim().split(/\s+/) || [];

        const keyInfo: SSHKeyInfo = {
            privatePath,
            publicPath,
            keyType: type,
            comment: email,
            hasPassphrase: !!passphrase,
        };

        // Get fingerprint
        try {
            const output = await execAsync('ssh-keygen', ['-lf', publicPath]);
            const fpMatch = output.match(/^\d+\s+([^\s]+)/);
            keyInfo.fingerprint = fpMatch?.[1];
        } catch {
            // Optional
        }

        await auditService.logSSHKeyGenerated(privatePath);
        logger.info('SSH key generated', { label, type, privatePath });

        return keyInfo;
    },

    /**
     * Get public key content (safe to share)
     */
    async getPublicKey(keyPath: string): Promise<string | null> {
        const pubPath = keyPath.endsWith('.pub') ? keyPath : `${keyPath}.pub`;
        return safeReadFile(pubPath);
    },

    /**
     * Add key to SSH agent
     */
    async addToAgent(keyPath: string): Promise<boolean> {
        try {
            await execAsync('ssh-add', [keyPath]);
            logger.info('Key added to SSH agent', { keyPath });
            return true;
        } catch (error) {
            logger.error('Failed to add key to agent', { keyPath, error });
            return false;
        }
    },

    /**
     * Get SSH config entries
     */
    async getSSHConfig(): Promise<SSHConfigEntry[]> {
        const configPath = getSSHConfigPath();
        const content = await safeReadFile(configPath);

        if (!content) {
            return [];
        }

        return parseSSHConfig(content);
    },

    /**
     * Add or update SSH config entry
     */
    async upsertSSHConfigEntry(entry: SSHConfigEntry): Promise<void> {
        const configPath = getSSHConfigPath();

        // Backup existing config
        const backup = await backupService.createBackup(configPath, 'ssh_config', 'Adding SSH config entry');

        // Get existing entries
        const entries = await this.getSSHConfig();

        // Find and update or add
        const index = entries.findIndex(e => e.host === entry.host);
        if (index >= 0) {
            entries[index] = { ...entries[index], ...entry };
        } else {
            entries.push(entry);
        }

        // Write back
        const content = generateSSHConfig(entries);
        await ensureDir(path.dirname(configPath));
        await fs.writeFile(configPath, content, { mode: 0o600 });

        await auditService.logSSHConfigUpdated(backup?.id);
        logger.info('SSH config entry added/updated', { host: entry.host });
    },

    /**
     * Remove SSH config entry
     */
    async removeSSHConfigEntry(host: string): Promise<boolean> {
        const configPath = getSSHConfigPath();

        // Backup existing config
        await backupService.createBackup(configPath, 'ssh_config', 'Removing SSH config entry');

        // Get existing entries
        const entries = await this.getSSHConfig();
        const filtered = entries.filter(e => e.host !== host);

        if (filtered.length === entries.length) {
            return false; // Not found
        }

        // Write back
        const content = generateSSHConfig(filtered);
        await fs.writeFile(configPath, content, { mode: 0o600 });

        await auditService.logSSHConfigUpdated();
        logger.info('SSH config entry removed', { host });

        return true;
    },

    /**
     * Test SSH connection
     */
    async testConnection(host: string): Promise<{ success: boolean; message: string }> {
        try {
            await execAsync('ssh', ['-T', '-o', 'StrictHostKeyChecking=no', '-o', 'BatchMode=yes', host]);
            return { success: true, message: 'Connection successful' };
        } catch (error) {
            const message = (error as Error).message;

            // GitHub returns exit code 1 with success message
            if (message.includes('successfully authenticated')) {
                return { success: true, message: 'Successfully authenticated' };
            }

            if (message.includes('Permission denied')) {
                return { success: false, message: 'Permission denied. SSH key not recognized.' };
            }

            return { success: false, message: `Connection failed: ${message}` };
        }
    },

    /**
     * Get SSH directory path
     */
    getSSHDirectory(): string {
        return getSSHDir();
    },
};

export default sshService;
